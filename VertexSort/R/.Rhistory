g = graph_from_atlas(sample(0:1252, 1))
library(igraph)
g = graph_from_atlas(sample(0:1252, 1))
g
V(g)
E(g)
V(g)$id
V(g)$name
vcount(g)
V(g)[nei(1:7,"in")]
V(g)[nei(1:7,"out")]
V(g)[nei(1,"out")]
V(g)[nei(1,"in")]
V(g)[V(g)$nei(1,"in")]
V(g)[neighbors(g, 1,"in")]
neighbors(g, 1,"in")
neighbors(g, 1,"in")$id
?neighbors
V(g)$id = 1:7
V(g)$name = 7:1
neighbors(g, 1,"in")
neighbors(g, 1,"in")$id
neighbors(g, 1, mode="in")$id
neighbors(g, 1, mode="out")$id
neighbors(g, 2, mode="out")$id
q()
getwd()
edges = read.table("I:/Firelite/Projects/Network_hierarchy_8/R Package/interactions.txt", header=T, sep = "\t", quote="\"",
                   stringsAsFactors=F)

head(edges)
names(edges) = c("actor_orf","target_orf")
vgraph = g
vnodes = scc_nodes_id[[1]]
g
vnodes
class(vnodes)
?clusters
V(vgraph)[c(24,53)]$orf
V(vgraph)[orf %in% c("YDR490C","YJL164C")]$id
V(vgraph)[orf %in% c("YDR490C","YJL164C")]$name
neighbors(vgraph, vnodes, mode="in")$name
neighbors(vgraph, vnodes, mode="out")$name
try = graph_from_atlas(sample(0:1252, 1))
E(try)
V(vgraph)[ nei(1:2, mode="in") ]$id
V(try)[ nei(1:2, mode="in") ]$id
V(try)[ nei(1:2, mode="in") ]
edgelist <- read.table(text = "
A B
B C
C D
D E
C F
F G")  

library(igraph)
graph <- graph.data.frame(edgelist)
graph
V(graph)[ nei(1:2, mode="in") ]$id
V(vgraph)[0]
V(vgraph)[1]
V(vgraph)[603]
V(graph)[ nei(1:2, mode="in") ]
neighbors(graph, 1:2, mode="in")
?neighbors
neighbors(graph, 1, mode="in")
neighbors(graph, 2, mode="in")
sapply(1:2, function(x) neighbors(graph, x, mode="in"))
unlist(sapply(1:2, function(x) neighbors(graph, x, mode="in")))
sapply(1:2, function(x) neighbors(graph, x, mode="in"), USE.NAMES=FALSE)
unlist(sapply(1:2, function(x) neighbors(graph, x, mode="in"), USE.NAMES=FALSE))
V(vgraph)[ nei(vnodes, mode="in") ]$id
unlist(sapply(vnodes, function(x) neighbors(try, x, mode="in")))
unlist(sapply(vnodes, function(x) neighbors(vgraph, x, mode="in")))
V(vgraph)[ nei(vnodes, mode="out") ]$id
unlist(sapply(vnodes, function(x) neighbors(vgraph, x, mode="out")))
unlist(sapply(vnodes, function(x) neighbors(vgraph, x, mode="out")))$id
unlist(sapply(vnodes, function(x) neighbors(vgraph, x, mode="out")$id))
V(vgraph)[ nei(vnodes, mode="out") ]$id
unlist(sapply(vnodes, function(x) neighbors(vgraph, x, mode="out")$name))
V(vgraph)[unlist(sapply(vnodes, function(x) neighbors(vgraph, x, mode="out")))]$id
V(vgraph)[ nei(vnodes, mode="out") ]$id
V(vgraph)[ nei(vnodes, mode="out") ]$name
sort(unlist(sapply(vnodes, function(x) neighbors(vgraph, x, mode="out"))))
V(vgraph)[ nei(vnodes, mode="out") ]$id
all(sort(unlist(sapply(vnodes, function(x) neighbors(vgraph, x, mode="out"))))==V(vgraph)[ nei(vnodes, mode="out") ]$id)
all(sort(unlist(sapply(vnodes, function(x) neighbors(vgraph, x, mode="out")$id)))==V(vgraph)[ nei(vnodes, mode="out") ]$id)
ls()
globalVariables(c("to", "edges_no"."swaping_no"))
globalVariables(c("to", "edges_no", "swaping_no"))
search()
search()[-1]
sys.frame(0)
sys.frame(-1)
prd
prid
pird
g
sys.frame(0)
str(sys.frame(0))
class(str(sys.frame(0)))
class(as.character(sys.frame(0)))
library(igraph)
get0("igraph")
parent.frame()
parent.frame(1)
parent.frame(2)
parent.frame(0)
parent.frame(-1)
parent.frame(7)
search()
environment()
environment(2)
parent.env()
parent.env(0)
parent.env(.GlobalEnv)
as.environment("package:igraph")
as.environment("package:igraph")[1]
class(as.environment("package:igraph"))
get("igraph")
sys.frame()
get("igraph")
get0("igraph")
get("igraph", sys.frame())
get(as.environment("package:igraph"), sys.frame())
as.environment("package:igraph")
library(Vertre)
library(VertexSort)
names(vs_kp_net)
library(GOstats)
library(igraph)
?degree
sessionInfo()
q()
sessionInfo()
q()
library(VertexSort)
sessionInfo()
sessionInfo()
sessionInfo()
library(GOstats)
sessionInfo()
library(igraph)
  all(igraph:degree(kp_net, V(kp_net), "in")==igraph:degree(rand_g[[1]], V(rand_g[[1]]), "in"))
  all(igraph::degree(kp_net, V(kp_net), "in")==igraph::degree(rand_g[[1]], V(rand_g[[1]]), "in"))
summary(vs_kp_net)
q()
library(VertexSort)
dim(df$edges)
dim(df$node_attribute)
?vertex.sort
?igraph
?rpid
head(vs_kp_net$edges)
?interactions
head(interactions)
?export.to.cytoscape
sessionInfo()
?VertexSort-package
q()
library(VertexSort)
?VertexSort-package
q()
library(VertexSort)
?VertexSort-package
detach(VertexSort-package)
detach(VertexSort)
rm(VertexSort)
unload(VertexSort)
detach("package:VertexSort", unload=TRUE)
?VertexSort-package
library(VertexSort)
?VertexSort-package
detach("package:VertexSort", unload=TRUE)
library(VertexSort)
?VertexSort-package
q()
library(VertexSort)
?VertexSort-package
sessionInfo()
q()
library(VertexSort)
?VertexSort-package
q()
library(VertexSort)
?VertexSort-package
?vertex.sort
q()
library(VertexSort)
rpd
switch_edges
Switch_edges
total <- 20
pb <- txtProgressBar(min = 0, max = total, style = 3)
for(i in 1:total){
   Sys.sleep(0.1)
   # update progress bar
   setTxtProgressBar(pb, i)
}
close(pb)
total <- 100
pb <- txtProgressBar(min = 0, max = total, style = 3)
for(i in 1:total){
   Sys.sleep(0.1)
   # update progress bar
   setTxtProgressBar(pb, i)
}
close(pb)
total <- 1000
pb <- txtProgressBar(min = 0, max = total, style = 3)
for(i in 1:total){
   Sys.sleep(0.1)
   # update progress bar
   setTxtProgressBar(pb, i)
}
close(pb)
total <- 20
pb <- tkProgressBar(title = "progress bar", min = 0,
                    max = total, width = 300)

for(i in 1:total){
   Sys.sleep(0.1)
   setTkProgressBar(pb, i, label=paste( round(i/total*100, 0),
                                        "% done"))
}
close(pb)
library(tcltk)
total <- 20
pb <- tkProgressBar(title = "progress bar", min = 0,
                    max = total, width = 300)

for(i in 1:total){
   Sys.sleep(0.1)
   setTkProgressBar(pb, i, label=paste( round(i/total*100, 0),
                                        "% done"))
}
close(pb)
total <- 200
pb <- tkProgressBar(title = "progress bar", min = 0,
                    max = total, width = 300)

for(i in 1:total){
   Sys.sleep(0.1)
   setTkProgressBar(pb, i, label=paste( round(i/total*100, 0),
                                        "% done"))
}
close(pb)
total <- 20
pb <- tkProgressBar(title = "progress bar", min = 0,
                    max = total, width = 300)

for(i in 1:total){
   Sys.sleep(0.1)
   setTkProgressBar(pb, i, label=paste( round(i/total*100, 0),
                                        "% done"))
}
close(pb)
total <- 20
pb <- txtProgressBar(min = 0, max = total, style = 3)
for(i in 1:total){
   Sys.sleep(0.1)
   # update progress bar
   setTxtProgressBar(pb, i)
}
close(pb)
?txtProgressBar
q()
sessionInfo()
?Sys.sleep
library(VertexSort)
rm(rand_g)
rand_g
class(rand_g)
length(rand_g)
rand_g[[1]]
  rand_g <- rpd(kp_net, 250, TRUE, 2)   # with parallel mode
  rand_g <- rpd(kp_net, 250)
  rand_g <- rpd(kp_net, 250, TRUE, 2)   # with parallel mode
  rand_g <- rpd(kp_net, 250)
  rand_g <- rpd(kp_net, 25)
  rand_g <- rpd(kp_net, 250, TRUE, 2)   # with parallel mode
Switch_edges
  rand_g <- rpd(kp_net, 250, TRUE, 2)   # with parallel mode
warnings()
log.socket <- make.socket(port=4000)

Log <- function(text, ...) {
  msg <- sprintf(paste0(as.character(Sys.time()), ": ", text, "\n"), ...)
  cat(msg)
  write.socket(log.socket, msg)
}
daytime <- function(host = "localhost"){
    a <- make.socket(host, 13)
    on.exit(close.socket(a))
    read.socket(a)
}
daytime("tick.usno.navy.mil")
log.socket <- make.socket(port=40)
log.socket <- make.socket(port=4000, server=T)
diala is now typing on the server
and this is the second line
and the third one
q
q()
exit
exit()
q()
q()
library(VertxSort)
library(VertexSort)
dim(interactions)
head(interactions)
dim(df)
class(df)
library(VertexSort)
?dpr
?dpr
dpr
library(VertexSort)
library(VertexSort)
dpr
dpr()
dpr <- function(vgraph, viteration_no, vparallel=FALSE, vcpus=1) {
  # Calls the Switch_edges function. Parallel running mode can be enabled.
  # The ultimate goal is to randomize a network by preserving its node in- and out-degrees
  # Args:
  #   vgraph: a graph object representing the network to randomize
  #   viteration_no: integer representing the number of random networks that we need to generate
  #   vparallel: a boolean variable. If it is equal to True, the funciton will run in parallel mode
  #   vcpus: an integer indicating the number of cpus to use in case parallel mode is on.
  # Returns:
  #   rand_vgraph: a list containing the randomized networks in the form of graph objects

  if ( class(vgraph)!="igraph" )
    stop("Error: first argument should be an igraph graph object")
  if ( class(viteration_no)!="numeric" )
    stop("Error: second argument should be an integer")
  if ( class(vparallel)!="logical" )
    stop("Error: third argument should be a logical")
  if ( class(vcpus)!="numeric" )
    stop("Error: fourth argument should be an integer")

  if (vparallel==T & vcpus==1)
    warning("If you would like to run your code in parallel mode, the number of cpus should be bigger than 1")

  edges_no    <- ecount(vgraph)
  swaping_no  <- edges_no*10
  edges       <- get.edgelist(vgraph)
  from        <- edges[,1]
  to          <- edges[,2]
  from_to     <- paste("t",edges[,1],edges[,2],"t")
  log_name    <- "dpr_log.txt"

  rand_vgraph <- NULL

  do.call("sfInit", list(parallel=vparallel, cpus=vcpus, slaveOutfile="slaveOutfile.txt"))

  igraph   <- as.environment("package:igraph")
  snowfall <- as.environment("package:snowfall")
  sfLibrary(snowfall)
  sfLibrary(igraph)

  Sub_switch_edges <- get0("Sub_switch_edges")
  sfExport("Sub_switch_edges", "vgraph", "swaping_no", "edges_no", "from", "to", "from_to", "viteration_no", "log_name")


  rand_vgraph <- do.call(list, sfClusterApplyLB(1:viteration_no, Switch_edges))

  sfStop()
  unlink(c(log_name, "slaveOutfile.txt"))

  return(rand_vgraph)
}

dpr()
dpr
q()
dpr
q()
